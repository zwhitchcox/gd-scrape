{"version":3,"sources":["App.tsx","reportWebVitals.ts","index.tsx"],"names":["gathered","parseTimeFrom","memoize","timeStr","hoursMatch","match","hours","parseInt","minutesMatch","minutes","daysMatch","days","startPatterns","INITIAL_CONSONANT_DIGRAPHS","FINAL_CONSONANT_DIGRAPHS","minute","hour","day","checkExpired","domain","_gathered","timeLeft","expires","Date","now","getTimeLeft","left","abs","Math","hoursLeft","minutesLeft","daysLeft","isVowel","letter","length","includes","isConsonant","perPage","App","useState","page","setPage","nextPage","window","scrollTo","prevPage","max","priceLimit","setPriceLimit","newPattern","setNewPattern","localStorage","JSON","parse","patterns","_setPatterns","setPatterns","pat","stringify","showPatternsExplanation","setShowPatternsExplanation","domains","setDomains","useEffect","a","fetch","resp","json","filterPatterns","Object","entries","key","push","console","log","filtered","slice","filter","name","price","some","pattern","str","replace","patI","strI","digraph","substr","test","Number","patternMatch","priceArr","split","result","join","priceToNumber","className","value","onChange","e","isNaN","target","onClick","map","type","checked","WebSocket","undefined","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.98db70c0.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport memoize from 'lodash/memoize'\nimport './App.scss';\n\nconst gathered = 1613967115931\n\nconst parseTimeFrom = memoize((timeStr: string) => {\n  const hoursMatch = timeStr.match(/(\\d)+H/)\n  const hours = (hoursMatch && parseInt(hoursMatch[1])) || 0\n  const minutesMatch = timeStr.match(/(\\d)+M/)\n  const minutes = (minutesMatch && parseInt(minutesMatch[1])) || 0\n  const daysMatch = timeStr.match(/(\\d)+D/)\n  const days = (daysMatch && parseInt(daysMatch[1])) || 0\n  return {\n    hours: hours,\n    minutes: minutes,\n    days: days,\n  }\n})\n\nconst VOWEL_SYMBOL = '_'\nconst CONSONANT_SYMBOL = '$'\nconst startPatterns = {\n  '_$_$': false,\n  '$_$_': true,\n  '$__$': false,\n  '$_0_': false,\n  '$_$2_': false,\n  '$_$$_': false,\n  '$_11$': false,\n  '$__$_': false,\n  '$o1$': false,\n  '$e1$': false,\n}\nconst INITIAL_CONSONANT_DIGRAPHS = [\n  'bl',\n  'br',\n  'ch',\n  'cl',\n  'cr',\n  'dr',\n  'fl',\n  'fr',\n  'gl',\n  'gr',\n  'ph',\n  'pl',\n  'pr',\n  'qu',\n  'sc',\n  'sh',\n  'sl',\n  'sm',\n  'sn',\n  'sp',\n  'st',\n  'sw',\n  'th',\n  'tr',\n  'tw',\n  'wh',\n  'wr',\n]\n\nconst FINAL_CONSONANT_DIGRAPHS = [\n  'ch',\n  'ck',\n  'gh',\n  'lt',\n  'st',\n  'th',\n  'sk',\n  'sh',\n  'sm',\n  'sp',\n  'ph',\n  'ng',\n]\n\nconst patternMatch = ((str: string, pattern: string) => {\n  // if (str.replace('.com', '').length !== pattern.length) {\n  //   return false\n  // }\n  str = str.replace('.com', '')\n  // if (str === \"truku\") {\n  //   debugger\n  // }\n  for (let patI = 0, strI = 0; strI < str.length; strI++, patI++) {\n    if (patI >= pattern.length) {\n      return false\n    }\n    const letter = str[strI]\n    const pat = pattern[patI]\n    if (pat === CONSONANT_SYMBOL) {\n      if (strI === 0) {\n        const digraph = str.substr(strI, 2)\n        if (INITIAL_CONSONANT_DIGRAPHS.includes(digraph)) {\n          strI++\n          continue\n        }\n      } else {\n        const digraph = str.substr(strI, 2)\n        if (FINAL_CONSONANT_DIGRAPHS.includes(digraph)) {\n          strI++\n          continue\n        }\n      }\n    }\n    if (pat === '*') {\n      continue\n    }\n    if (pat === CONSONANT_SYMBOL) {\n      if (!isConsonant(letter)) {\n        return false\n      }\n    } else if (pat === VOWEL_SYMBOL) {\n      if (!isVowel(letter)) {\n        return false\n      }\n    } else if (/[0-9]/.test(pat)) {\n      if (letter !== str[Number(pat)]) {\n\n        return false\n      }\n    } else if (letter !== pat) {\n      return false\n    }\n  }\n  return true\n})\n\nconst minute = 60 * 1000\nconst hour = 60 * minute\nconst day = 24 * hour\nconst checkExpired = memoize((domain) => {\n  const _gathered = domain.gathered || gathered\n  const {hours, minutes, days}  = parseTimeFrom(domain.timeLeft)\n  const expires = _gathered + days*day + hours*hour + minutes*minute\n  return Date.now() > expires\n})\n\nconst getTimeLeft = memoize(domain => {\n  const _gathered = domain.gathered || gathered\n  const {hours, minutes, days}  = parseTimeFrom(domain.timeLeft)\n  const expires = _gathered + days*day + hours*hour + minutes*minute\n  const left = Date.now() - expires\n  const { abs } = Math\n  const hoursLeft = abs((left % day) / hour | 0)\n  const minutesLeft = abs((left % hour) / minute | 0)\n  const daysLeft = abs((left / day | 0))\n  return {\n    hoursLeft,\n    minutesLeft,\n    daysLeft,\n  }\n})\n\n\nconst isVowel = (letter:string) => (\n  letter.length === 1 && ['a','e','i','o','u','y'].includes(letter)\n)\nconst isConsonant = (letter:string) => !isVowel(letter)\nconst priceToNumber = (price:string) => {\n  const priceArr = price.split('')\n  const result:any = []\n  for (const letter of priceArr) {\n    if (/[0-9]/.test(letter)) {\n      result.push(letter)\n    }\n  }\n  return Number(result.join(''))\n}\n\nconst perPage = 20000\nfunction App() {\n  const [page, setPage] = useState(0)\n  const nextPage = () => {\n    window.scrollTo(0,0)\n    setPage(page + 1)\n  }\n  const prevPage = () => setPage(Math.max(0, page - 1))\n\n  const [priceLimit, setPriceLimit] = useState(10000)\n  const [newPattern, setNewPattern] = useState(\"\")\n  const [patterns, _setPatterns] = useState<{[key: string]: boolean}>(() => {\n    if (localStorage['patterns']) {\n      return JSON.parse(localStorage['patterns'])\n    }\n    return startPatterns\n  })\n  const setPatterns = (pat) => {\n    localStorage['patterns'] = JSON.stringify(pat)\n    _setPatterns(pat)\n  }\n  const [showPatternsExplanation, setShowPatternsExplanation] = useState(false)\n  const [domains, setDomains] = useState<{\n    name: string\n    price: string\n    timeLeft: string\n  }[]>([])\n  useEffect(() => {\n    ;(async() => {\n      const resp = await fetch('/gd-scrape/domains.json')\n      const domains = await resp.json()\n      setDomains(domains)\n    })()\n  }, [])\n  const filterPatterns: string[] = []\n  for (const [key, value] of Object.entries(patterns)) {\n    if (value) {\n      filterPatterns.push(key)\n    }\n  }\n  console.log(filterPatterns)\n  const filtered = domains\n    .slice(perPage*page, perPage*page + perPage)\n    .filter(domain => {\n      const { name, price } = domain\n      return filterPatterns.some(pattern => patternMatch(name, pattern))\n        && priceToNumber(price) < Number(priceLimit)\n        && !checkExpired(domain)\n    })\n\n  return (\n    <div className=\"App\">\n      <label className=\"price-limit\">\n        price limit: <input\n          value={priceLimit}\n          onChange={(e:any) => {\n            if(!Number.isNaN(Number(e.target.value)))\n              setPriceLimit(e.target.value)\n          }}\n          />\n      </label>\n      <label className=\"new-pattern\">\n        new pattern: <input\n          value={newPattern}\n          onChange={(e:any) => {\n              setNewPattern(e.target.value)\n          }}\n          />\n      </label>\n      <div className=\"btns\">\n        <button className=\"add-new-pattern\" onClick={() => {\n          setPatterns({\n            ...patterns,\n            [newPattern]: true\n          })\n          setNewPattern(\"\")\n        }}>\n          Add Pattern\n        </button>\n        <button\n          className=\"explanation\"\n          onClick={() => {\n            setShowPatternsExplanation(!showPatternsExplanation)\n          }}>\n          How Patterns Work\n        </button>\n      </div>\n      {!showPatternsExplanation ? \"\" : (\n        <div>\n          <p>\n            A '$' represents a consonant. This includes consonant digraphs (th, st, etc.)\n          </p>\n          <p>\n            A '_' represents a vowel.\n          </p>\n          <p>\n            Any letter represents itself.\n          </p>\n          <p>\n            A number represents the 0-indexed character in the string. So, for a domain that's all the same letter, I would make the pattern '$000', that's consonant, then the same consonant, then the same consonant, then the same consonant, e.g. cccc.\n          </p>\n          <p>\n            A '*' can represent any character.\n          </p>\n        </div>\n      )}\n      <div className=\"patterns\">\n        {Object.entries(patterns).map(([key, value]) => {\n          return (\n            <label onClick={() => {\n              setPatterns({\n                ...patterns,\n                [key]: !value\n              })\n            }}>\n              <input type=\"checkbox\" checked={value} />\n              {key}\n            </label>\n          )\n        })}\n      </div>\n      <div>\n        Page: {page + 1} &nbsp;\n        <button onClick={prevPage}>\n          Prev Page\n        </button>\n        <button onClick={nextPage}>\n          Next Page\n        </button>\n      </div>\n      <table>\n        <tbody>\n        {filtered.map(domain => {\n          const timeLeft = getTimeLeft(domain)\n          const { daysLeft, minutesLeft, hoursLeft } = timeLeft\n          return (\n            <tr>\n              <td>{domain.name}</td>\n              <td>{domain.price}</td>\n              <td>\n                {daysLeft ? `${daysLeft}D ` : \"\"}\n                {hoursLeft ? `${hoursLeft}H ` : \"\"}\n                {minutesLeft ? `${minutesLeft}M ` : \"\"}\n              </td>\n            </tr>\n          )\n        })}\n        </tbody>\n      </table>\n      <div>\n        Page: {page + 1} &nbsp;\n        <button onClick={prevPage}>\n          Prev Page\n        </button>\n        <button onClick={nextPage}>\n          Next Page\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n\n(window as any).WebSocket = undefined","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}